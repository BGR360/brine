use std::{collections::hash_map::Entry, path::PathBuf};

use bevy::{
    asset::{AssetPath, HandleId, LoadState},
    prelude::*,
    utils::{HashMap, HashSet},
};

use brine_data::{
    block::{BlockStateId, Blocks},
    MinecraftData,
};

use crate::mesh::VoxelMesh;

const TEXTURES_PATH: &str = "1.14.4/assets/minecraft/textures/block/";
const PLACEHOLDER_PATH: &str = "placeholder.png";

pub fn get_texture_path(block_state: BlockStateId, blocks: &Blocks) -> Option<PathBuf> {
    let block_name = &blocks.get_block_by_state_id(block_state)?.name;

    let mut path = PathBuf::from(TEXTURES_PATH);
    path.push(format!("{}.png", block_name));

    Some(path)
}

struct PendingAtlas {
    textures: Vec<Handle<Image>>,
    handle: Handle<TextureAtlas>,
}

impl PendingAtlas {
    fn all_textures_loaded(&self, asset_server: &AssetServer) -> bool {
        self.textures
            .iter()
            .all(|handle| asset_server.get_load_state(handle) != LoadState::Loading)
    }
}

#[derive(Default)]
pub struct BlockTextures {
    /// Strong handle to a placeholder texture.
    placeholder_texture: Handle<Image>,

    /// Map from block state to texture handle.
    block_state_to_texture: HashMap<BlockStateId, Handle<Image>>,

    /// Texture atlases that have yet to be built because not all of the
    /// textures have loaded yet.
    pending_atlases: Vec<PendingAtlas>,
}

impl BlockTextures {
    /// Returns a handle to the texture for a provided block state, or a handle
    /// to a placeholder texture if that does not exist.
    pub fn get_or_load_texture<'a, F, P>(
        &mut self,
        block_state: BlockStateId,
        asset_server: &mut AssetServer,
        mut get_path: F,
    ) -> Handle<Image>
    where
        F: FnMut(BlockStateId) -> Option<P>,
        P: Into<AssetPath<'a>>,
    {
        match self.block_state_to_texture.entry(block_state) {
            Entry::Occupied(handle) => {
                let handle = handle.get().clone();
                //assert!(asset_server.get_load_state(&handle) == LoadState::Loaded);
                handle
            }
            Entry::Vacant(entry) => {
                let handle = get_path(block_state)
                    .map(|path| asset_server.load(path.into()))
                    .unwrap_or_else(|| self.placeholder_texture.clone());

                entry.insert(handle.clone());
                handle
            }
        }
    }

    /// Returns a handle to a [`TextureAtlas`] that includes the textures for
    /// all of the block states in `block_states`.
    ///
    /// If no such texture atlas exists yet, it will be generated by the plugin
    /// as soon as all of the required textures have been loaded.
    ///
    /// If any textures need to be loaded, the `asset_server` and `get_path`
    /// closure will be used to load them.
    pub fn create_texture_atlas<'a, B, F, P>(
        &mut self,
        block_states: B,
        asset_server: &mut AssetServer,
        mut get_path: F,
    ) -> Handle<TextureAtlas>
    where
        B: IntoIterator<Item = BlockStateId>,
        F: FnMut(BlockStateId) -> Option<P>,
        P: Into<AssetPath<'a>>,
    {
        let mut block_states = block_states.into_iter().collect::<Vec<_>>();

        // Sort block states for determinism.
        block_states.sort_by_key(|block_state| block_state.0);

        debug!(
            "Texture atlas requested for block states: {:?}",
            &block_states
        );

        let textures = block_states
            .into_iter()
            .map(|block_state| self.get_or_load_texture(block_state, asset_server, &mut get_path))
            .collect();

        let handle_id = HandleId::random::<TextureAtlas>();
        let handle = asset_server.get_handle(handle_id);

        // The vended handle needs to be strong so that the atlas isn't dropped
        // as soon as it is added to the `Assets` in `finish_texture_atlases`.
        assert!(handle.is_strong());

        self.pending_atlases.push(PendingAtlas {
            textures,
            handle: handle.clone(),
        });

        handle
    }

    /// Builds a [`TextureAtlas`] out of each [`PendingAtlas`] that is ready to
    /// be built, and inserts it into [`Assets<TextureAtlas>`].
    pub(crate) fn finish_texture_atlases(
        &mut self,
        asset_server: &AssetServer,
        texture_atlases: &mut Assets<TextureAtlas>,
        textures: &mut Assets<Image>,
    ) {
        self.pending_atlases.retain(|pending_atlas| {
            if pending_atlas.all_textures_loaded(asset_server) {
                debug!(
                    "Building texture atlas for textures: {:?}",
                    &pending_atlas.textures
                );

                let mut builder = TextureAtlasBuilder::default();
                for handle in pending_atlas.textures.iter() {
                    let handle = if textures.contains(handle) {
                        handle
                    } else {
                        debug!("here");
                        &self.placeholder_texture
                    };
                    let texture = textures.get(handle).unwrap();
                    builder.add_texture(handle.clone_weak(), texture);
                    assert!(textures.get(handle).is_some());
                }

                let atlas = builder.finish(textures).unwrap();

                // It's okay to ignore the returned handle, we know that we
                // already vended out at least one strong handle when
                // `create_texture_atlas` was called.
                let _ = texture_atlases.set(&pending_atlas.handle, atlas);

                false
            } else {
                true
            }
        });
    }
}

/// Plugin that assembles texture atlases for voxel meshes.
pub struct TextureBuilderPlugin;

impl Plugin for TextureBuilderPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<BlockTextures>();
        app.add_startup_system(Self::load_placeholder_texture);
        app.add_system(Self::create_texture_atlases);
        app.add_system(Self::finish_texture_atlases);
    }
}

impl TextureBuilderPlugin {
    /// This system loads the placeholder texture at program startup.
    fn load_placeholder_texture(
        mut block_textures: ResMut<BlockTextures>,
        asset_server: ResMut<AssetServer>,
    ) {
        block_textures.placeholder_texture = asset_server.load(PLACEHOLDER_PATH);
    }

    /// This system iterates through all newly created [`VoxelMesh`]es and kicks
    /// off the creation of a [`TextureAtlas`] for each one. A
    /// [`Handle<TextureAtlas>`] is inserted on each entity processed by this
    /// system.
    #[allow(clippy::type_complexity)]
    fn create_texture_atlases(
        query: Query<(Entity, &VoxelMesh), (Added<VoxelMesh>, Without<Handle<StandardMaterial>>)>,
        mc_data: Res<MinecraftData>,
        mut block_textures: ResMut<BlockTextures>,
        mut asset_server: ResMut<AssetServer>,
        mut commands: Commands,
    ) {
        for (entity, mesh) in query.iter() {
            // Get all the unique block states that are present in this mesh.
            let block_states = Self::get_block_states_in_mesh(mesh);

            let atlas_handle = block_textures.create_texture_atlas(
                block_states,
                &mut asset_server,
                |block_state| get_texture_path(block_state, &mc_data.blocks),
            );

            commands.entity(entity).insert(atlas_handle);
        }
    }

    fn get_block_states_in_mesh(mesh: &VoxelMesh) -> HashSet<BlockStateId> {
        let mut block_states_in_mesh = HashSet::default();
        for block_state in mesh.voxel_values.iter() {
            block_states_in_mesh.insert(BlockStateId(block_state.0 as u16));
        }
        block_states_in_mesh
    }

    /// This system calls [`BlockTextures::finish_texture_atlases`] once per
    /// frame to build texture atlases that are ready to be built.
    fn finish_texture_atlases(
        asset_server: Res<AssetServer>,
        mut block_textures: ResMut<BlockTextures>,
        mut texture_atlases: ResMut<Assets<TextureAtlas>>,
        mut textures: ResMut<Assets<Image>>,
    ) {
        block_textures.finish_texture_atlases(&asset_server, &mut texture_atlases, &mut textures);
    }
}
