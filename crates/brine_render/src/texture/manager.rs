use bevy::{asset::HandleId, prelude::*, render::options::WgpuOptions, utils::HashMap};

use brine_asset::TextureKey;

use crate::texture::{PendingAtlas, TextureAtlas};

const PLACEHOLDER_PATH: &str = "placeholder.png";

#[derive(Debug)]
pub struct TextureManager {
    /// Strong handle to a placeholder texture.
    placeholder_texture: Handle<Image>,

    /// The largest texture size allowed by the rendering backend.
    max_texture_size: u32,

    /// A strong handle to each of the texture atlases generated by calls to
    /// `stitch_atlas`.
    atlases: Vec<Handle<TextureAtlas>>,

    /// Mapping from texture key to index into the `atlases` list.
    key_to_atlas: HashMap<TextureKey, usize>,

    /// List of atlases that are waiting for their textures to be loaded.
    pending_atlases: Vec<PendingAtlas>,
}

impl TextureManager {
    pub fn new(placeholder_texture: Handle<Image>, max_texture_size: u32) -> Self {
        Self {
            placeholder_texture,
            max_texture_size,
            atlases: Default::default(),
            key_to_atlas: Default::default(),
            pending_atlases: Default::default(),
        }
    }

    /// Returns a handle to a texture atlas that contains the given texture.
    ///
    /// Returns `None` if the given texture is not contained in any atlas.
    pub fn get_atlas(&self, texture: TextureKey) -> Option<Handle<TextureAtlas>> {
        self.key_to_atlas
            .get(&texture)
            .map(|index| self.atlases[*index].clone())
    }

    /// Returns a handle that will eventually be populated with a stitched
    /// texture atlas composed of the given textures.
    ///
    /// The textures need not be loaded at the time of calling this method.
    pub fn create_atlas<T>(
        &mut self,
        asset_server: &AssetServer,
        textures: T,
    ) -> Handle<TextureAtlas>
    where
        T: IntoIterator<Item = (TextureKey, Handle<Image>)>,
    {
        let textures: Vec<_> = textures.into_iter().collect();

        debug!("Texture atlas requested for {} textures", textures.len());

        let handle_id = HandleId::random::<TextureAtlas>();
        let handle = asset_server.get_handle(handle_id);

        let pending_atlas = PendingAtlas {
            handle: handle.clone(),
            textures,
        };
        self.pending_atlases.push(pending_atlas);

        handle
    }

    pub fn atlases(&self) -> impl Iterator<Item = &Handle<TextureAtlas>> {
        self.atlases.iter()
    }

    pub fn try_stitch_pending_atlases(
        &mut self,
        textures: &mut Assets<Image>,
        atlases: &mut Assets<TextureAtlas>,
    ) {
        if !textures.contains(&self.placeholder_texture) {
            return;
        }

        self.pending_atlases.retain(|pending_atlas| {
            let is_ready = pending_atlas.all_textures_loaded(textures);

            if is_ready {
                let atlas_handle = pending_atlas.handle.clone();
                let atlas = TextureAtlas::stitch(
                    textures,
                    pending_atlas
                        .textures
                        .iter()
                        .map(|(key, handle)| (*key, handle)),
                    &self.placeholder_texture,
                    self.max_texture_size,
                );

                let index = self.atlases.len();
                for texture_key in atlas.regions.keys() {
                    self.key_to_atlas.insert(*texture_key, index);
                }

                atlases.set_untracked(&atlas_handle, atlas);
                self.atlases.push(atlas_handle);
            }

            // Remove it from the list if we just stitched it.
            !is_ready
        });
    }
}

impl FromWorld for TextureManager {
    fn from_world(world: &mut World) -> Self {
        let asset_server = world.get_resource::<AssetServer>().unwrap();
        let placeholder_texture = asset_server.load(PLACEHOLDER_PATH);

        let wgpu_limits = &world.get_resource::<WgpuOptions>().unwrap().limits;
        let max_texture_size = wgpu_limits.max_texture_dimension_2d;

        Self::new(placeholder_texture, max_texture_size)
    }
}

pub struct TextureManagerPlugin;

impl Plugin for TextureManagerPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<TextureManager>();
        app.add_asset::<TextureAtlas>();
        app.add_system(stitch_pending_atlases);
    }
}

fn stitch_pending_atlases(
    mut manager: ResMut<TextureManager>,
    mut textures: ResMut<Assets<Image>>,
    mut atlases: ResMut<Assets<TextureAtlas>>,
) {
    manager.try_stitch_pending_atlases(&mut *textures, &mut *atlases);
}
