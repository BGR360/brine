use bevy::{
    asset::{AssetServer, Assets, Handle, HandleId},
    log::*,
    render::texture::Image,
    utils::HashMap,
};

use brine_asset::storage::TextureKey;

use crate::texture::{PendingAtlas, TextureAtlas};

#[derive(Debug)]
pub struct TextureManager {
    /// Strong handle to a placeholder texture.
    placeholder_texture: Handle<Image>,

    /// A strong handle to each of the texture atlases generated by the plugin.
    atlases: Vec<Handle<TextureAtlas>>,

    /// Mapping from texture key to index into the `atlases` list.
    key_to_atlas: HashMap<TextureKey, usize>,

    /// List of atlases that are waiting for their textures to be loaded.
    pending_atlases: Vec<PendingAtlas>,
}

impl TextureManager {
    /// Returns a handle to the texture atlas that contains the given texture.
    pub fn get_atlas(&self, texture: TextureKey) -> Option<Handle<TextureAtlas>> {
        self.key_to_atlas
            .get(&texture)
            .map(|index| self.atlases[*index].clone())
    }

    pub fn create_atlas<T>(
        &mut self,
        asset_server: &AssetServer,
        textures: T,
    ) -> Handle<TextureAtlas>
    where
        T: IntoIterator<Item = (TextureKey, Handle<Image>)>,
    {
        let textures: Vec<_> = textures.into_iter().collect();

        debug!("Texture atlas requested for {} textures", textures.len());

        let handle_id = HandleId::random::<TextureAtlas>();
        let handle = asset_server.get_handle(handle_id);

        let pending_atlas = PendingAtlas {
            handle: handle.clone(),
            textures,
        };
        self.pending_atlases.push(pending_atlas);

        handle
    }

    pub(crate) fn new(placeholder_texture: Handle<Image>) -> Self {
        Self {
            placeholder_texture,
            atlases: Default::default(),
            key_to_atlas: Default::default(),
            pending_atlases: Default::default(),
        }
    }

    pub(crate) fn try_stitch_pending_atlases(
        &mut self,
        textures: &mut Assets<Image>,
        atlases: &mut Assets<TextureAtlas>,
    ) {
        if !textures.contains(&self.placeholder_texture) {
            return;
        }

        self.pending_atlases.retain(|pending_atlas| {
            let is_ready = pending_atlas.all_textures_loaded(textures);

            if is_ready {
                let atlas_handle = pending_atlas.handle.clone();
                let atlas = TextureAtlas::stitch(
                    textures,
                    pending_atlas
                        .textures
                        .iter()
                        .map(|(key, handle)| (*key, handle)),
                    &self.placeholder_texture,
                );

                let index = self.atlases.len();
                for texture_key in atlas.regions.keys() {
                    self.key_to_atlas.insert(*texture_key, index);
                }

                atlases.set_untracked(&atlas_handle, atlas);
                self.atlases.push(atlas_handle);
            }

            // Remove it from the list if we just stitched it.
            !is_ready
        });
    }
}
